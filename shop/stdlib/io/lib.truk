shard "stdio";

cimport <stdio.h>;

import "types.truk";
import "io.truk";

fn io_ok(value: i32) : io_result_s {
  return io_result_s{value: value, ok: true};
}

fn io_err(value: i32) : io_result_s {
  return io_result_s{value: value, ok: false};
}

fn io_is_ok(r: *io_result_s) : bool {
  return (*r).ok;
}

fn io_is_err(r: *io_result_s) : bool {
  return !(*r).ok;
}

fn io_unwrap(r: *io_result_s) : i32 {
  return (*r).value;
}

fn io_unwrap_or(r: *io_result_s, default_value: i32) : i32 {
  if (*r).ok {
    return (*r).value;
  }
  return default_value;
}

fn io_and_then(r: *io_result_s, f: fn(i32) : io_result_s) : io_result_s {
  if (*r).ok {
    return f((*r).value);
  }
  return *r;
}

fn io_or_else(r: *io_result_s, f: fn(i32) : io_result_s) : io_result_s {
  if !(*r).ok {
    return f((*r).value);
  }
  return *r;
}

fn io_map(r: *io_result_s, f: fn(i32) : i32) : io_result_s {
  if (*r).ok {
    return io_ok(f((*r).value));
  }
  return *r;
}

fn io_print(msg: *u8) : io_result_s {
  return _io_print(msg);
}

fn io_println(msg: *u8) : io_result_s {
  return _io_println(msg);
}

fn io_eprint(msg: *u8) : io_result_s {
  return _io_eprint(msg);
}

fn io_eprintln(msg: *u8) : io_result_s {
  return _io_eprintln(msg);
}

fn io_write_stdout(buf: *u8, count: i32) : io_result_s {
  return _io_write_stdout(buf, count);
}

fn io_write_stderr(buf: *u8, count: i32) : io_result_s {
  return _io_write_stderr(buf, count);
}

fn io_read_stdin(buf: *u8, count: i32) : io_result_s {
  return _io_read_stdin(buf, count);
}

fn io_open(filename: *u8, mode: *u8) : (*u8, io_result_s) {
  return _io_open(filename, mode);
}

fn io_close(f: *u8) : io_result_s {
  return _io_close(f);
}

fn io_flush(f: *u8) : io_result_s {
  return _io_flush(f);
}

fn io_write_file(f: *u8, buf: *u8, count: i32) : io_result_s {
  return _io_write_file(f, buf, count);
}

fn io_read_file(f: *u8, buf: *u8, count: i32) : io_result_s {
  return _io_read_file(f, buf, count);
}

fn io_with_file(filename: *u8, mode: *u8, handler: fn(*u8) : io_result_s) : io_result_s {
  let f, open_result = io_open(filename, mode);
  if io_is_err(&open_result) {
    return open_result;
  }
  
  defer {
    io_close(f);
  }
  
  return handler(f);
}
