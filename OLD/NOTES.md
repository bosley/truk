
### 17, DEC, 2025

When I was initially writing the tests to confirm behavior, I was mostly interested in making sure things like variable assignments, reassignment, typechecker, etc. were all working. The parts of the compiler that are the internal libs `verification`, `ingestion`, and `language` all have their own unit tests, but they aren't integration-tested in C++ directly. These tests served as those integration tests. The reason there are so many is that I wanted to test as many variations of each sub-feature as I could imagine/encounter to ensure that the `.truk -> C -> bin` pipeline is well covered.

When/if we go to LLVM instead of C, we can use these tests for the same correctness fitment.

Once I got all of the base types, map type runtime structure, and lambdas worked in, I started ironing out the implementation (I think the branch was called ironing-board or some such) where I made integer and float literals untyped. What I mean is that the parser and tree would read in the integers and have them be i32 or i64, which had the typechecker upset when we did things like `i += 1` if `i` happened to NOT be i64 as I decided to make strong type comparisons. I completely neglected to consider untyped literals, so once I fit that in I got away from having to `as` everything (still lots of tests with it present). During this time, I also put the sugar in to make struct pointers friendlier to work with, `ptr->val` vs `(*ptr).val` everywhere. Again, I pushed through this for a long time to ensure I didn't get sidetracked in implementing niceties.

At the time of writing, I got `let` worked in with tuple returns. I discovered a limitation in how I generate C for tuple returns where slices of objects can't be directly bundled in a tuple, but you can do so if you place them in a struct first. I could refactor things to iron this out, and I believe it SHOULD be done, but for now, I detect the problem and throw at compile time if it's detected.

From there I thought "we really need more tests" because as I piled on lambda, let, etc., I realized that the C code gen is clean on small programs, but the moment you bring anything of substance in, it's a rat's nest and hard to debug. Granted, the end user (someone using truk) SHOULD NEVER have to be aware of C the same way a C++ dev doesn't have to be aware of ASM, but for the effort of the development of the compiler, it's NUTS. Since the tests are here now in sxs fw we can start ironing out the `let` issue and enure that everything is stable as we do it after we setup some scaffolding (tests that preserve current fucntionality)

That led me to now where I just got done reworking the `truk` command itself to have a new subcommand `test` that detects test structures and injects test structures into truk and the runtime to do truk-centric tests. Right now it `cimport`s to itself (don't worry about it), but once we get this whole thing baked to a solid workable language we will have standard imports, one of which will be a "testing" import that wraps the ugly `cimport` meta include on the runtime we are presently doing in a nice clean truk-centric way (as a private shard set on a public api) â€” the same with stdio / networking / etc. The plan/goal is to define the structures that make truk worth using over C, then abstract C as a sort of "HAL" so we can get the "Base usable language" up and running. Then, once we have it, test the ever-living fuck out of it to ensure it's correct and resilient to changes. ONLY then will I start having fun in the language and compiling lists of bugs as we use it. ONLY then will I start using the thing, and that's when I will wrap sockets, IO, all that jazz.

When we start having std libs to use and it's "generally usable," I want to make my personal website in it (server), but I'm targeting rewriting `insi`, the distributed k/v eventing datastore.

Once truk gets up and becomes a fuller language set, it will be "higher level" than it is currently and the target will be parallelization through processes forking and selectable synchronization with external processes (remote or local).
